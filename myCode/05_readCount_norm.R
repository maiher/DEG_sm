#rm(list = ls())

# base conda is fine!


# Readcount normalization edgeR RNAseq Richard
#
# data analysis before: 
# /data2/230406_RBrown_HEPG2/230413_RNAseq_HEPG2.sh

# !!! this script requires input files generated by featureCounts !!! #

# within single samples: reads/fragments per kb mil
# RPKM values are for single-end reads! 
# FPKM are for paired-end data!!! FPKM takes into account that 2 reads (of a pair) can map to the same fragment, which then isn't counted twice

# among samples: TPM: transcripts per kilobase milion - but better use DESeq2!


# formulas:
# p$rpkm <- (10^9)*(as.numeric(p[,i]))/(as.numeric(gLen)*rCountSum)     # add rpkm col to df
# (10^9)*                         # (1 Milliarde=) 1 billion times - why not 10⁶? i.e. 1 million: then the genelen in kb is used, ie. geneLen/1000
# (as.numeric(rCount))            # read count per individual gene
# /                               # devided by
# (as.numeric(gLen)*rCountSum)    # (individual gene length * total sum of reads for sample (= library size))

# TPM =  10⁶ * A / sumA
# A = (rCount * 10³) / gLen
# sumA = sum of A values in sample (all genes)


# 1. -O featureCounts
#outFile <- '/data2/240122_RKoenig_humanHSPC/240126_featureCount/SAMHD1_HPC_readCounts_O_norm.csv'
# --complement: keep all but these. Works for any no of samples!
#p <- read.table(pipe("cut --complement -f2,3,4,5 '/data2/240122_RKoenig_humanHSPC/240126_featureCount/SAMHD1_HPC_readCounts_O.csv'"),
#                sep="\t", dec = ".", header=TRUE)


# 2. no -O featureCounts
#outFile <- '/data2/240409_RKoenig_mouseGL261_round2/240411_featureCount/mouseGL261_readCounts_norm.csv'

outFile <- '/home/AD/hermi/sm_tutorial/BYOC/testrun/240526_featureCount/mouseGL261_readCounts_norm.csv'

# --complement: keep all but these. Works for any no of samples!
#'/data2/240409_RKoenig_mouseGL261_round2/240411_featureCount/mouseGL261_readCounts.csv'"),

p <- read.table(pipe("cut --complement -f2,3,4,5 '/home/AD/hermi/sm_tutorial/BYOC/testrun/240526_featureCount/mouseGL261_readCounts.csv'"),
                sep="\t", dec = ".", header=TRUE)
#p <- read.table('/data2/230913_Calu3_Huh7_A549_HepG2/230914_featureCount/Calu3_Huh7_A549_HepG2_readCounts.csv', sep="\t", dec = ".", header=TRUE)


# I think nothing below must change!


colnames(p)
# fields 2-5 before cutting:
#[2] "Chr"                                                                                              
#[3] "Start"                                                                                            
#[4] "End"                                                                                              
#[5] "Strand"                                                                                           

# after cutting:
# Field1: geneId
# Field2: geneLen
# Field3: Sample1 read counts
# Field4: Sample2 read counts

# set index=geneIds, but keep column 1
rownames(p) <- p[,1]
len <- ncol(p)



# edit colnames:
# ---------------
colnames(p)
# removes path:
#   from "X.data2.230828_RBrown_YFV_PHH.230828_align.Uganda_3_S45_R1_001_inf1Aligned.sortedByCoord.out.bam"]
#   to "Uganda_3_S45_R1_001_inf1Aligned.sortedByCoord.out.bam"
q <- '.*_align.'
cNames <- gsub(q, '', colnames(p))
cNames
#   deletes query '_S' and all after query:
#   from "Uganda_3_S45_R1_001_inf1Aligned.sortedByCoord.out.bam"
#   to  "Uganda_3"
q <- '_S.*'
cNames <- gsub(q, '', cNames)
cNames
# rename columns:
colnames(p) <- cNames



# gene length column
gLen <- p$Length

# for the sample columns (starting with the 3., going till the end)
for(i in 3:ncol(p))
{
  rCount <-p[,i]                                                        # sample readCount column  
  rCountSum <- sum(as.numeric(p[,i]))                                   # total mapped reads per sample (sum of readCount column)
  p$rpkm <- (10^9)*((as.numeric(rCount))/(as.numeric(gLen)*rCountSum))     # add rpkm col to df
  sName <- names(p)[i]                                                  # sample name from readCount column  
  names(p)[names(p) == 'rpkm'] <- paste0('RPKM_',sName)                 # rename results col: access name of column that matches 'rpkm', add sample col name
  rpk <- (as.numeric(rCount))/(as.numeric(gLen)/1000)                   # rpk: reads per kilobase
  sFak <- sum(as.numeric(rpk))/(10^6)                                   # scaling factor: total sample rpk values / 1 mio
  p$tpm <- rpk/sFak                                                     # tpm transcripts per million
  names(p)[names(p) == 'tpm'] <- paste0('TPM_',sName)                   # rename tpm results col
}

print(colnames(p))

# output:
write.table(p, outFile, sep="\t", row.names=FALSE)

